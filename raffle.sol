// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.22;

contract Raffle {

    //참여자 구조체
    struct application {
        //참여자이름
        string name;
        //참여자구분
        string num;
        //당첨여부
        uint win;
    }

    //설문조사 구조체
    struct survey {
        uint raffleTime;
        uint surveyId;
    }

    mapping(string => application) Applications;
    mapping (uint => survey) Surveys;
    
    //automate interval 시간
    uint interval = 1;
    //참여자 배열
    string[] key;
    // address ownerAddress;
    // uint[] time;

    //automate 시간
    uint keyTime;
    //radom함수 당첨
    uint public idx;
    //automate test
    uint public count;
    
    //설문 등록 
    function setSurvey(uint timeStamp,uint surveyId) public {
        // ownerAddress = msg.sender;
        Surveys[surveyId] = survey(timeStamp,surveyId);
        // time.push(timeStamp);

        //automate 시간 설정 
        keyTime = timeStamp;
    }

    //설문 가져오기 
    function getSurvey(uint surveyId) public view returns (uint){
        uint raffleTime = Surveys[surveyId].raffleTime;
        return raffleTime;
    }

    //참여자 등록
    function addApplicator(string memory _name,string memory _num) public {
        Applications[_num] = application(_name,_num,0);
        key.push(_num);
    }

    //참여자 삭제
    function deleteApplicator() public {
        // require(ownerAddress == msg.sender);
        
        for(uint i=0;i<key.length;i++){
            delete Applications[key[i]];
        }
        delete key;
    }
    

    //참여자 가져오기
    function getApplicator(string memory _num) public view returns(string memory, string memory , uint ){
        string memory name = Applications[_num].name;
        string memory num = Applications[_num].num;
        uint win = Applications[_num].win;
        return (name,num,win);
    }

    //전체 참여자 가져오기
    function getAllAppicator() public view returns(string [] memory){
        return key;
    }


    //random test
    function random() public {
        uint seed = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, block.number)));
        if(key.length > 0){
            idx = seed % key.length;
            Applications[key[idx]].win = 1;
        }
    }

    //당첨자 
    function winning() public view returns(string memory, string memory ) {
        string memory name = Applications[key[idx]].name;
        string memory num = Applications[key[idx]].num;
        return (name,num);
    }

//automate
// checkUpKeep : 인터벌이 돌았나 체크합니다. 돌았으면 performUpKeep을 실행합니다.
// performUpKeep : 인터벌 마다 실행하는 동작을 정의합니다. 

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {

        upkeepNeeded = (block.timestamp - keyTime) > interval;

        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - keyTime) > interval) {
            count = count+1;
            uint seed = uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, block.number)));
            if(key.length > 0){
                idx = seed % key.length;
                Applications[key[idx]].win = 1;
            }
            keyTime = block.timestamp + block.timestamp;

        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }


}